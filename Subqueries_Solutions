--üîπ LEVEL 1 ‚Äî Easy Subqueries (Warm-up)
--Q1. From table: employees(emp_id, emp_name, salary) Find employees who earn more than the average salary.
SELECT * FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);


--Q2. From table: employees(emp_id, emp_name, dept_id). Find employees who work in the same department as employee with emp_id = 101.
SELECT DISTINCT emp_id, emp_name, dept_id FROM employees WHERE dept_id IN (SELECT dept_id FROM employees WHERE emp_id = 101);

--Q3. From table: products(product_id, price). Find products whose price is higher than the minimum price.
SELECT * FROM products WHERE price > (SELECT MIN(price) FROM products);

--üîπ LEVEL 2 ‚Äî Medium Subqueries (Interview-Core)
--Q4. From table: orders(order_id, customer_id, amount) Find customers whose total order amount is greater than the average order amount of all customers.
-- SELECT customer_id, SUM(amount) AS total_amount FROM orders GROUP BY customer_id HAVING SUM(amount) > (SELECT AVG(amount) FROM orders);‚ùå
SELECT customer_id, SUM(amount) AS total_amount 
FROM orders 
GROUP BY customer_id 
HAVING SUM(amount) > 
	(
		SELECT AVG(customer_total) 
		FROM (
				SELECT customer_id, SUM(amount) AS customer_total 
				FROM orders 
				GROUP BY customer_id
			)t
	);

--Q5. From table: employees(emp_id, emp_name, dept_id, salary) Find employees who earn more than the average salary of their department.
-- SELECT emp_id, emp_name FROM employees e WHERE salary > (SELECT AVG(salary) FROM employees d GROUP BY dept_id ON d.dept_id=e.dept_id);‚ùå
SELECT emp_id, emp_name
FROM employees e
WHERE salary > (
	SELECT AVG(salary)
	FROM employees
	GROUP BY dept_id
	WHERE dept_id = e.dept_id
	);

--Q6. From table: students(student_id, marks) Find students who scored above the class average.
SELECT student_id FROM students WHERE marks > (SELECT AVG(marks) FROM students);

--üîπ LEVEL 3 ‚Äî Hard Subqueries (Advanced Interview)
--Q7. From table: employees(emp_id, emp_name, dept_id, salary) Find the highest paid employee in each department.
SELECT emp_id, emp_name FROM employees e WHERE (dept_id, salary) IN (SELECT dept_id, MAX(salary) FROM employees GROUP BY dept_id);

--Q8. From table: orders(order_id, customer_id, order_date) Find customers who placed an order on their first day of signup. (Table customers(customer_id, signup_date))
-- SELECT customer_id FROM customers c WHERE signup_date = (SELECT TOP 1 order_date FROM orders o ORDER BY order_date ASC ON c.customer_id = o.customer_id);‚ùå
SELECT c.customer_id
FROM customers c
WHERE c.signup_date IN (
    SELECT o.order_date
    FROM orders o
    WHERE o.customer_id = c.customer_id
);


--Q9. From table: sales(order_date, product_id, amount) Find products whose total sales are greater than the overall average sales across all products.
-- SELECT product_id FROM sales WHERE (SELECT product_id, SUM(amount) AS total_sales FROM sales s GROUP BY products HAVING SUM(amount) > (SELECT AVG(amount) FROM products));‚ùå
SELECT product_id, SUM(amount) AS total_sales
FROM sales
GROUP BY product_id
HAVING SUM(amount) >
(
    SELECT AVG(product_total)
    FROM (
        SELECT SUM(amount) AS product_total
        FROM sales
        GROUP BY product_id
    ) t
);


--üîπ LEVEL 4 ‚Äî Very Hard Subqueries (Data-Engineering Level)
--Q10. From table: transactions(user_id, txn_date, amount) Find users whose first transaction amount is greater than their average transaction amount.
-- SELECT user_id FROM transactions t WHERE amount > (SELECT AVG(amount) FROM transactions GROUP BY user_id ORDER BY txn_date ASC ON t.user_id = user_id);‚ùå
SELECT t1.user_id
FROM transactions t1
WHERE t1.txn_date =
(
    SELECT MIN(txn_date)
    FROM transactions
    WHERE user_id = t1.user_id
)
AND t1.amount >
(
    SELECT AVG(amount)
    FROM transactions
    WHERE user_id = t1.user_id
);


--Q11. From table: employees(emp_id, emp_name, dept_id, salary) Find departments where all employees earn more than 40,000.
SELECT dept_id FROM employees WHERE (dept_id, salary) IN (SELECT dept_id, MIN(salary) FROM employees GROUP BY dept_id HAVING MIN(salary) > 40000);

-- OR --

SELECT dept_id FROM employees GROUP BY dept_id HAVING MIN(salary) > 40000;

--Q12. From table: logs(user_id, log_date) Find users who logged in on every day present in the logs table.
--SELECT user_id FROM logs l1 GROUP BY user_id HAVING COUNT(DISTINCT log_date) > (SELECT COUNT(DISTINCT log_date) FROM logs GROUP BY user_id ON l1.user_id = user_id);‚ùå
SELECT user_id
FROM logs
GROUP BY user_id
HAVING COUNT(DISTINCT log_date) =
(
    SELECT COUNT(DISTINCT log_date)
    FROM logs
);

/*
‚ùå Your Current Query (Why it‚Äôs wrong)
SELECT user_id
FROM logs l1
GROUP BY user_id
HAVING COUNT(DISTINCT log_date) = (
    SELECT COUNT(DISTINCT log_date)
    FROM logs
    WHERE user_id = l1.user_id
);

üî¥ The logical issue

Both sides of the comparison are counting log_date for the same user.

So this condition becomes:
COUNT(user's days) = COUNT(user's days)

‚úÖ What the question actually means

‚ÄúUsers who logged in on every day present in the logs table‚Äù

That means:
(number of days this user logged in)
=
(total distinct days that exist in the system)

‚úÖ Correct & Interview-Perfect Solution
SELECT user_id
FROM logs
GROUP BY user_id
HAVING COUNT(DISTINCT log_date) =
(
    SELECT COUNT(DISTINCT log_date)
    FROM logs
);
*/
