-- üîπ SET 1 ‚Äî UNION / UNION ALL (Precision)
-- Q1.
-- Tables:
-- active_customers(customer_id)
-- inactive_customers(customer_id)
-- Return customers who were active at some point but are NOT active now.
-- ‚úÖ Correct query
SELECT ic.customer_id
FROM inactive_customers ic
WHERE NOT EXISTS (
    SELECT 1
    FROM active_customers ac
    WHERE ac.customer_id = ic.customer_id
);

-- Q2. ‚ö†Ô∏è Interview Trap
-- Tables:
-- orders_2023(order_id)
-- orders_2024(order_id)
-- Return duplicate order_ids that exist in both tables.
-- üëâ No JOIN allowed.
SELECT order_id 
FROM (
	SELECT order_id FROM orders_2023
	UNION ALL 
	SELECT order_id FROM orders_2024
) t
GROUP BY order_id
HAVING COUNT(*) > 1;

-- OR --
SELECT order_id FROM orders_2023
INTERSECT
SELECT order_id FROM orders_2024;

-- üîπ SET 2 ‚Äî EXISTS / NOT EXISTS (Logic Depth)
-- Q3.
-- Tables:
-- employees(emp_id)
-- leaves(emp_id, leave_date)
-- Return employees who never took any leave.
SELECT emp_id 
FROM employees e 
WHERE NOT EXISTS (
	SELECT 1 
	FROM leaves le 
	WHERE le.emp_id = e.emp_id
);

-- Q4. ‚ö†Ô∏è Logic Test
-- Tables:
-- customers(customer_id)
-- orders(order_id, customer_id, amount)
-- Return customers who placed orders only once.
-- üëâ Use EXISTS / NOT EXISTS
-- üëâ No GROUP BY in outer query
-- ‚úÖ Correct query
SELECT c.customer_id
FROM customers c
WHERE EXISTS (
    SELECT 1
    FROM orders o1
    WHERE o1.customer_id = c.customer_id
)
AND NOT EXISTS (
    SELECT 1
    FROM orders o2
    WHERE o2.customer_id = c.customer_id
    AND o2.order_id <> (
        SELECT MIN(order_id)
        FROM orders o3
        WHERE o3.customer_id = c.customer_id
    )
);

-- OR --

SELECT c.customer_id 
FROM customers c 
WHERE EXISTS (
	SELECT 1
	FROM orders o 
	WHERE o.customer_id = c.customer_id
	GROUP BY o.customer_id
	HAVING COUNT(*) = 1
);

-- üîπ SET 3 ‚Äî ANY / ALL (Interview Favorite)
-- Q5.
-- Table:
-- employees(emp_id, salary, dept_id)
-- Return employees whose salary is greater than ALL salaries in department 20.
-- ‚úÖ Correct query
SELECT emp_id 
FROM employees 
WHERE salary > ALL (
	SELECT salary
	FROM employees
	WHERE dept_id = 20
);

-- Q6.
-- Table:
-- products(product_id, price)
-- Return products whose price is less than ANY premium product price
-- (premium = price > 50,000).
SELECT product_id
FROM products 
WHERE price < ANY (
	SELECT price
	FROM products 
	WHERE price > 50000
);

-- üîπ SET 4 ‚Äî CASE WHEN (Business Logic)
-- Q7.
-- Table:
-- employees(emp_id, joining_date)
-- Return: emp_id | experience_level
-- Rules:
-- ‚â• 5 years ‚Üí Senior
-- 2‚Äì4 years ‚Üí Mid
-- < 2 years ‚Üí Junior
-- ‚úÖ Correct query
SELECT emp_id,
       CASE
           WHEN DATEDIFF(CURRENT_DATE, joining_date) / 365 >= 5 THEN 'Senior'
           WHEN DATEDIFF(CURRENT_DATE, joining_date) / 365 BETWEEN 2 AND 4 THEN 'Mid'
           ELSE 'Junior'
       END AS experience_level
FROM employees;

-- üß† In interviews, avoid AGE unless PostgreSQL is confirmed.
SELECT emp_id, CASE
	WHEN y >= 5 THEN 'Senior'
	WHEN y BETWEEN 2 AND 4 THEN 'Mid'
	ELSE 'Junior'
  END AS experience_level
FROM (
	SELECT emp_id, joining_date, AGE(CURRENT_DATE, joining_date, YEAR) AS y 
	FROM employees
) t;

-- Q8.
-- Table:
-- orders(order_id, amount)
-- Return total count of orders by category:
-- High (>= 20000)
-- Medium (10000‚Äì19999)
-- Low (< 10000)
SELECT order_category, COUNT(*) AS total_orders
FROM (
	SELECT order_id, amount, CASE 
		WHEN amount >= 20000 THEN 'High'
		WHEN amount BETWEEN 10000 AND 19999 THEN 'Medium'
		ELSE 'Low'
	  END AS order_category
	FROM orders 
) t 
GROUP BY order_category;

-- üîπ SET 5 ‚Äî Date Functions (Accuracy)
-- Q9.
-- Table:
-- orders(order_id, order_date)
-- Return orders placed in the previous calendar month (not last 30 days).
-- ‚úÖ Correct query
SELECT order_id
FROM orders
WHERE order_date >= DATE_FORMAT(CURRENT_DATE - INTERVAL 1 MONTH, '%Y-%m-01')
  AND order_date <  DATE_FORMAT(CURRENT_DATE, '%Y-%m-01');

-- Q10. ‚ö†Ô∏è Common Mistake
-- Table:
-- employees(emp_id, joining_date)
-- Return employees who joined on a Monday.
SELECT emp_id 
FROM employees
WHERE DAYNAME(joining_date) = 'Monday';

-- üîπ SET 6 ‚Äî Window Functions (Allowed Only)
-- Q11.
-- Table:
-- employees(emp_id, dept_id, salary)
-- Return lowest paid employee per department.
SELECT emp_id 
FROM (
	SELECT emp_id, dept_id, salary, 
		RANK() OVER(PARTITION BY dept_id ORDER BY salary ASC) AS lowest_first
	FROM employees
) t 
WHERE t.lowest_first = 1;

-- Q12.
-- Table:
-- sales(order_date, amount)
-- Return:
-- order_date | daily_total | previous_day_total
-- ‚úÖ Correct query
SELECT order_date,
       daily_total,
       LAG(daily_total) OVER (ORDER BY order_date) AS previous_day_total
FROM (
    SELECT order_date,
           SUM(amount) AS daily_total
    FROM sales
    GROUP BY order_date
) t;


-- üîπ SET 7 ‚Äî Views (Real-World)
-- Q13.
-- Create a view that shows department-wise total salary.
CREATE VIEW dept_total_salary AS
SELECT dept_id, SUM(salary) AS total_salary
FROM employees
GROUP BY dept_id;


-- Q14. ‚ö†Ô∏è Conceptual
-- Can a view created using a window function be updated?
-- Answer YES / NO with one precise reason.
‚úÖ Correct answer

NO
Reason:
Views containing window functions are not updatable because they do not map rows 1-to-1 with base tables.

--üß† One-line interview answer. Memorize.

-- üîπ SET 8 ‚Äî üî• Recursive CTE (NEW ‚Äì Very Important)
-- Q15. (Easy Start)
-- Table:
-- numbers(n) containing values 1‚Äì10
-- Generate numbers from 1 to 10 using WITH RECURSIVE.
-- ‚úÖ Correct query
WITH RECURSIVE nums AS (
	SELECT 1 AS n 
	UNION ALL 
	SELECT n+1 
	FROM nums 
	WHERE n < 10
)
SELECT * FROM nums;

-- Q16. (Classic Interview)
-- Table:
-- employees(emp_id, manager_id)
-- Return employee ‚Üí manager hierarchy starting from the CEO (manager_id IS NULL).
-- ‚úÖ Correct query
WITH RECURSIVE emp_tree AS (
    SELECT emp_id, manager_id, 0 AS level
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    SELECT e.emp_id, e.manager_id, et.level + 1
    FROM employees e
    JOIN emp_tree et ON e.manager_id = et.emp_id
)
SELECT * FROM emp_tree;

-- Q17. ‚ö†Ô∏è Logic Depth
-- Table:
-- org(emp_id, manager_id, salary)
-- Return total salary under each manager, including indirect reports.
-- üëâ Must use recursive CTE.
‚è≥ Not attempted (expected)

-- üîπ SET 9 ‚Äî Debug & Fix (Think Carefully)
-- Q18. ‚ùå What‚Äôs wrong?
-- SELECT dept_id, AVG(salary)
-- FROM employees
-- WHERE AVG(salary) > 70000
-- GROUP BY dept_id;
SELECT dept_id, AVG(salary)
FROM employees
GROUP BY dept_id
HAVING AVG(salary) > 70000;

-- Q19. ‚ùå Fix the logic
-- SELECT emp_id
-- FROM employees
-- WHERE salary = MAX(salary);
SELECT emp_id 
FROM employees
WHERE salary = (
	SELECT MAX(salary)
	FROM employees
);

-- üîπ SET 10 ‚Äî üíÄ Killer Question
-- Q20.
-- Table:
-- transactions(user_id, txn_date)
-- Return users who made transactions on exactly two consecutive days only
-- (not more, not less).
‚è≥ Not attempted (expected)
