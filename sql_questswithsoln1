/*
üîπ PART 1 ‚Äî UNION / UNION ALL (High-Yield Practice)
Q1. Basic UNION
Tables:
online_orders(order_id, customer_id)
offline_orders(order_id, customer_id)

Return unique customer_ids who placed orders from either source.
*/
SELECT customer_id FROM online_orders
UNION
SELECT customer_id FROM offline_orders;

/*
Q2. UNION ALL vs UNION

Same tables as Q1.
Return total number of orders placed, counting duplicates if the same order exists in both tables.
üëâ Decide: UNION or UNION ALL?
*/
SELECT COUNT(*) AS total_orders
FROM (
    SELECT order_id FROM online_orders
    UNION ALL
    SELECT order_id FROM offline_orders
) t;

-- UNION ALL - all values from combinationation with duplicates | UNION - all values from combinations withut duplicates

/*
Q3. Column Mismatch Trap ‚ö†Ô∏è

Tables:
employees(emp_id, emp_name)
contractors(contractor_id, contractor_name, end_date)

Return a combined list:
id | name | type

Where type = 'EMPLOYEE' or 'CONTRACTOR'.
*/
SELECT emp_id AS id, emp_name AS name, 'EMPLOYEE' AS type
FROM employees
UNION
SELECT contractor_id AS id, contractor_name AS name, 'CONTRACTOR' AS type
FROM contractors;

/*
Q4. Date Filter + UNION

Tables:
sales_2024(order_id, amount, sale_date)
sales_2025(order_id, amount, sale_date)

Return all orders after 1st Jan 2025, without duplicates.
*/
SELECT order_id, amount, sale_date
FROM sales_2024
WHERE sale_date > '2025-01-01'
UNION
SELECT order_id, amount, sale_date
FROM sales_2025
WHERE sale_date > '2025-01-01';
-- Filtering after UNION is inefficient | DISTINCT unnecessary because UNION already dedups

/*
Q5. UNION with ORDER BY (Interview Favorite)

Combine:
domestic_customers(customer_id, city)
international_customers(customer_id, country)

Return:
customer_id | location

Sorted by customer_id.
‚ö†Ô∏è Constraint: ORDER BY must be applied correctly.
*/
SELECT customer_id, location
FROM (
	SELECT customer_id, city AS location
	FROM domestic_customers
	UNION
	SELECT customer_id, country AS location
	FROM international_customers
) t 
ORDER BY customer_id;

/*
Q6. Performance Thinking
Same table:
transactions(txn_id, user_id)

Query A:

SELECT user_id FROM transactions
UNION
SELECT user_id FROM transactions;

Query B:

SELECT user_id FROM transactions
UNION ALL
SELECT user_id FROM transactions;

üëâ Which is faster and why?
*/
--UNION performs duplicate elimination (sorting or hashing), which is expensive.
--UNION ALL simply appends rows, so it is faster and uses fewer resources.

/*
üîπ PART 2 ‚Äî VIEWS (Very Important for Real Jobs)
Q7. Basic View

Table:
employees(emp_id, dept_id, salary)

Create a view that shows only employees earning more than 60,000.
*/
CREATE VIEW high_salary AS
	SELECT emp_id, dept_id, salary
	FROM employees
	WHERE salary > 60000;


/*
Q8. View with Aggregation

Create a view that returns:
dept_id | avg_salary
*/
CREATE VIEW dept_average_salary AS
	SELECT dept_id, AVG(salary) AS avg_salary
	FROM employees
	GROUP BY dept_id;

/*
Q9. View + WHERE Clause
Using the view from Q8, return departments where avg_salary > 70,000.
*/
SELECT * FROM dept_average_salary
WHERE avg_salary > 70000;

/*
Q10. Update Through View ‚ö†Ô∏è
View:
high_paid_employees(emp_id, salary)

Based on:
employees
üëâ Can you UPDATE salary using this view?
If yes ‚Üí when?
If no ‚Üí why?
(Answer in words, not SQL.)
*/
-- A simple view on a single table can be updatable. Aggregated or joined views are not updatable.

/*
Q11. View with JOIN

Tables:
orders(order_id, customer_id, amount)
customers(customer_id, city)

Create a view showing order_id, amount, city.
*/
CREATE VIEW view1 AS (
	SELECT o.order_id, o.amount, c.city 
	FROM orders o 
	JOIN customers c 
	ON o.customer_id = c.customer_id
);

SELECT * FROM view1;

/*
Q12. Drop vs Replace
What is the difference between:

DROP VIEW
CREATE OR REPLACE VIEW

Give one real use case.
*/
-- DROP VIEW- deleting the entire views entities and structure from the schemas
-- REPLACE VIEW - modifying existing View
-- CREATE VIEW - creation of new View 
--DROP VIEW ‚Üí removes the view completely
--CREATE OR REPLACE VIEW ‚Üí updates definition without breaking dependencies

/*
üîπ PART 3 ‚Äî EXTRA PRACTICE (Your Weak Zones üî•)
Q13. EXISTS vs IN (NULL Trap)

Tables:
customers(customer_id)
orders(order_id, customer_id)

Return customers who never placed an order.

üëâ Write 2 queries:
One using NOT IN
One using NOT EXISTS
Then answer: which is safer and why?
*/
-- NOT IN (dangerous)
SELECT customer_id
FROM customers
WHERE customer_id NOT IN (
    SELECT customer_id
    FROM orders
    WHERE customer_id IS NOT NULL
);

-- NOT EXISTS (safe)
SELECT c.customer_id
FROM customers c
WHERE NOT EXISTS (
    SELECT 1
    FROM orders o
    WHERE o.customer_id = c.customer_id
);

-- Correct conclusion
--‚ùå NOT IN is unsafe if subquery returns NULL
--‚úÖ NOT EXISTS is always safe

/*
Q14. Window Frame Trap
Table:
employees(emp_id, dept_id, salary)

Write a query that returns:
emp_id | salary | dept_min_salary

üëâ Must use LAST_VALUE
üëâ Must give correct result
*/
SELECT emp_id, salary,
LAST_VALUE(salary) OVER (
    PARTITION BY dept_id
    ORDER BY salary DESC
    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
) AS dept_min_salary
FROM employees;


/*
Q15. UNION + Window Function (Hard)
Tables:
sales_online(order_id, amount, sale_date)
sales_store(order_id, amount, sale_date)

Combine both sources and return:
order_id | amount | running_total

Where running_total is ordered by sale_date.
*/
-- I am not aware of it. I have to learn this topic first

/*
Q16. NTILE + UNION
Combine two employee tables:

india_employees(emp_id, salary)
us_employees(emp_id, salary)

Return top 20% highest paid employees globally.
*/
-- I am not aware of it. I have to learn this topic first

/*
Q17. View + Window Function (Real Project Style)
Create a view that shows:

emp_id | dept_id | salary | dept_rank

Where dept_rank is salary rank within department.
*/
CREATE VIEW v1 AS (
	SELECT emp_id, dept_id, salary, 
		DENSE_RANK() OVER(PARTITION BY dept_id ORDER BY salary DESC) AS dept_rank
	FROM employees
);

SELECT * FROM v1;
