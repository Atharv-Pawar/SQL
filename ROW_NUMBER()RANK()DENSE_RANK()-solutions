--ðŸ”¹ LEVEL 1 â€” Window Function Basics
--Q1. From table: employees(emp_id, dept_id, salary) Assign a unique row number to each employee ordered by salary (highest first).
SELECT *, ROW_NUMBER() OVER(ORDER BY salary DESC) AS rn
FROM employees;

--Q2. From table: students(student_id, marks) 
--Assign ranks to students based on marks (highest marks = rank 1).
--Tied marks should get the same rank and skip ranks.
SELECT *, RANK() OVER(ORDER BY marks DESC) AS _rank_
FROM students;

-- Q3. From table: products(product_id, category, price)
--Assign row numbers within each category, ordered by price (lowest first).
SELECT *, ROW_NUMBER() OVER(PARTITION BY category ORDER BY price) AS rn
FROM products;

--ðŸ”¹ LEVEL 2 â€” ROW_NUMBER vs RANK vs DENSE_RANK
/*
Q4. From table: employees(emp_id, dept_id, salary)

Rank employees by salary within each department using:

ROW_NUMBER

RANK

DENSE_RANK
ðŸ‘‰ Return all three ranks side by side.
*/
SELECT *, 
	ROW_NUMBER() OVER(PARTITION BY dept_id ORDER BY salary DESC) AS rn,
	RANK() OVER(PARTITION BY dept_id ORDER BY salary DESC) AS r,
	DENSE_RANK() OVER(PARTITION BY dept_id ORDER BY salary DESC) AS d 
FROM employees;

-- Q5. From table: students(student_id, subject, marks)
-- Return the top 2 students per subject, considering ties.
WITH top_students_per_subjects AS (
	SELECT student_id, subject, marks, DENSE_RANK() OVER(PARTITION BY subject ORDER BY marks DESC) AS d 
	FROM students
	) SELECT student_id, subject 
	FROM top_students_per_subjects 
	WHERE d <= 2;

-- Q6. âš ï¸ Interview Trap From table: employees(emp_id, salary)
-- Find the second highest salary, handling duplicates correctly.
SELECT emp_id, salary
FROM (
	SELECT emp_id, salary, DENSE_RANK() OVER(ORDER BY salary DESC) AS d 
	FROM employees
	) t
WHERE d = 2;

--ðŸ”¹ LEVEL 3 â€” Real Interview Problems
-- Q7. From table: orders(order_id, customer_id, order_date)
-- Return the latest order per customer using window functions.
SELECT customer_id, order_id 
FROM (
	SELECT *, RANK() OVER(PARTITION BY customer_id ORDER BY order_date DESC) AS _rank_
	FROM orders
	) t
WHERE _rank_ = 1;

-- Q8. From table: employees(emp_id, dept_id, salary)
-- Return employees who earn more than the department average ðŸ‘‰ You must use a window function.
-- ðŸ‘‰ You must use a window function.
-- ðŸ“Œ Important rule (interview language):
-- Window functions must be used in the condition that drives the result, not just displayed.
SELECT emp_id, dept_id, salary
FROM (
    SELECT emp_id,
           dept_id,
           salary,
           AVG(salary) OVER (PARTITION BY dept_id) AS dept_avg_salary
    FROM employees
) t
WHERE salary > dept_avg_salary;

-- Q9. From table: logins(user_id, login_date)
-- Find the first login date and latest login date for each user using window functions.
SELECT DISTINCT user_id,
       FIRST_VALUE(login_date) OVER (PARTITION BY user_id ORDER BY login_date) AS first_login_date,
       FIRST_VALUE(login_date) OVER (PARTITION BY user_id ORDER BY login_date DESC) AS latest_login_date
FROM logins;

--ðŸ”¹ LEVEL 4 â€” Advanced Window Logic (Data Engineer Level)
-- Q10. From table: employees(emp_id, dept_id, salary)
-- Find the top 3 salaries per department, but return all employees tied at the 3rd position.
WITH TOP_3_SALARIES_PER_DEPT AS (
	SELECT *, DENSE_RANK() OVER(PARTITION BY dept_id ORDER BY salary DESC) AS d
	FROM employees
	) SELECT *
	FROM TOP_3_SALARIES_PER_DEPT
	WHERE d <= 3;

-- Q11. From table: transactions(user_id, txn_date, amount)
-- Assign a sequential transaction number per user ordered by transaction date.
SELECT *, ROW_NUMBER() OVER(PARTITION BY user_id ORDER BY txn_date ASC) AS transaction_number
FROM transactions;

-- Q12. ðŸ”¥ Very Common Interview Question
-- From table: employees(emp_id, dept_id, salary)
-- Find departments where at least 2 employees share the same salary.
SELECT DISTINCT dept_id
FROM (
	SELECT dept_id,
	       salary,
	       COUNT(*) OVER (PARTITION BY dept_id, salary) AS cnt
	FROM employees
) t
WHERE cnt >= 2;

--ðŸ”¹ LEVEL 5 â€” Window Functions (Tricky / Thinking Required)
-- Q13. From table: orders(order_id, customer_id, order_date)
-- Identify repeat customers:
-- First order â†’ label as New
-- Subsequent orders â†’ label as Repeat
WITH category AS (
	SELECT *, ROW_NUMBER() OVER(PARTITION BY customer_id ORDER BY order_date ASC) AS sequence_of_order
	FROM orders
	)
SELECT *, CASE
	WHEN sequence_of_order = 1 THEN 'New'
	ELSE 'Repeat'
	END AS category_of_customers
FROM category;

-- Q14. From table: employees(emp_id, dept_id, salary, salary_month)
-- Find employees whose salary rank improved compared to the previous month
-- (Table also has salary_month).
/*
emp_id| dept_id| salary| salary_month| sal_mon_r | sal_r
1	601		2500	JAN		3		2		
1	601		2565	FEB		2		1			
1	601		2565	MAR 	1		1			
---------------------------------------------------------------------
2	601		2300	NOV		2		1		
2	601		2300	DEC 	1		1		
---------------------------------------------------------------------
3	604		1900	APR		3		3		
3	604		1920	MAY		2		2		
3	604		1940	JUN		1  		1				

*/âŒ
--You ranked by salary_month DESC (wrong)
--You compared two unrelated ranks
--You did not compare previous month rank
WITH rank_as_per_month AS (
	SELECT *, DENSE_RANK() OVER(PARTITION BY dept_id, emp_id ORDER BY salary_month DESC) AS salary_month_wise_rank,
	DENSE_RANK() OVER(PARTITION BY dept_id, emp_id ORDER BY salary DESC) AS salary_wise_rank
	FROM employees
	)
SELECT emp_id
FROM rank_as_per_month
WHERE salary_month_wise_rank = salary_wise_rank
GROUP BY emp_id
HAVING COUNT(*) > 1;

-- Q15. ðŸ’€ Interview Killer
-- From table: scores(student_id, exam_date, marks)
-- Find students whose rank improved in consecutive exams.
/*
PARTITION BY student_id| exam_date ASC| marks | rank OVER(ORDER BY exam_date) | rank OVER(ORDER BY marks DESC)
1	01-01-2026	97	1	2
1	02-01-2026	96	2	3
1	03-01-2026	99	3	1
---------------------------------
2	01-01-2026	98	1	1
2 	02-01-2026	91	2	4
2	03-01-2026	94	3	3
2	04-01-2026	95	4	2
----------------------------------
3	01-01-2026	98	1	1
3 	02-01-2026	92	2	2
3	03-01-2026	92	3	2
3	04-01-2026	92	4	2

*/âŒ
--Ranking by exam order â‰  ranking improvement
--Must compare rank vs previous rank
--Needs LAG()
WITH rank_as_per_exam_date_marks AS (
	SELECT *, DENSE_RANK() OVER(PARTITION BY student_id ORDER BY exam_date ASC) AS rank_as_per_examdate,
	DENSE_RANK() OVER(PARTITION BY student_id ORDER BY marks DESC) AS rank_as_per_marks
	FROM scores
	)
SELECT student_id
FROM rank_as_per_exam_date_marks
WHERE rank_as_per_examdate = rank_as_per_marks
GROUP BY student_id
HAVING COUNT(*) >= 1;
