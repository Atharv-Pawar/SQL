--üîπ LEVEL 1 ‚Äî Window Function Basics
--Q1. From table: employees(emp_id, dept_id, salary) Assign a unique row number to each employee ordered by salary (highest first).
SELECT *, ROW_NUMBER() OVER(ORDER BY salary DESC) AS rn
FROM employees;

--Q2. From table: students(student_id, marks) 
--Assign ranks to students based on marks (highest marks = rank 1).
--Tied marks should get the same rank and skip ranks.
SELECT *, RANK() OVER(ORDER BY marks DESC) AS _rank_
FROM students;

-- Q3. From table: products(product_id, category, price)
--Assign row numbers within each category, ordered by price (lowest first).
SELECT *, ROW_NUMBER() OVER(PARTITION BY category ORDER BY price) AS rn
FROM products;

--üîπ LEVEL 2 ‚Äî ROW_NUMBER vs RANK vs DENSE_RANK
/*
Q4. From table: employees(emp_id, dept_id, salary)

Rank employees by salary within each department using:

ROW_NUMBER

RANK

DENSE_RANK
üëâ Return all three ranks side by side.
*/
SELECT *, 
	ROW_NUMBER() OVER(PARTITION BY dept_id ORDER BY salary DESC) AS rn,
	RANK() OVER(PARTITION BY dept_id ORDER BY salary DESC) AS r,
	DENSE_RANK() OVER(PARTITION BY dept_id ORDER BY salary DESC) AS d 
FROM employees;

-- Q5. From table: students(student_id, subject, marks)
-- Return the top 2 students per subject, considering ties.
WITH top_students_per_subjects AS (
	SELECT student_id, subject, marks, DENSE_RANK() OVER(PARTITION BY subject ORDER BY marks DESC) AS d 
	FROM students
	) SELECT student_id, subject 
	FROM top_students_per_subjects 
	WHERE d <= 2;

-- Q6. ‚ö†Ô∏è Interview Trap From table: employees(emp_id, salary)
-- Find the second highest salary, handling duplicates correctly.‚ùå
SELECT emp_id, salary
FROM employees e1
WHERE EXISTS (
	SELECT emp_id, salary, DENSE_RANK() OVER(ORDER BY salary DESC) AS d 
	FROM employees
	WHERE d = 2 
	AND 
	emp_id = e1.emp_id
	);

--üîπ LEVEL 3 ‚Äî Real Interview Problems
-- Q7. From table: orders(order_id, customer_id, order_date)
-- Return the latest order per customer using window functions.‚ùå
SELECT customer_id, order_id 
FROM orders o1
WHERE EXISTS (
	SELECT *, RANK() OVER(PARTITION BY customer_id ORDER BY order_date DESC) AS _rank_
	FROM orders
	WHERE _rank_ = 1
	AND 
	order_id = o1.order_id
	);

-- Q8. From table: employees(emp_id, dept_id, salary)
-- Return employees who earn more than the department average üëâ You must use a window function.
-- üëâ You must use a window function.
SELECT *, 
	ROW_NUMBER() OVER(PARTITION BY dept_id ORDER BY salary DESC) AS _row_number_,
	RANK() OVER(PARTITION BY dept_id ORDER BY salary DESC) AS _rank_,
	DENSE_RANK() OVER(PARTITION BY dept_id ORDER BY salary DESC) AS _dense_rank_
FROM employees e1
WHERE salary > (
	SELECT AVG(salary) 
	FROM employees
	GROUP BY dept_id
	WHERE dept_id = e1.dept_id
	);

-- Q9. From table: logins(user_id, login_date)
-- Find the first login date and latest login date for each user using window functions.‚ùå
WITH login_date_first AS (
	SELECT *, 
		ROW_NUMBER() OVER(PARTITION BY user_id ORDER BY login_date ASC) AS starting_as_first
	FROM logins
	),
WITH login_date_latest AS (
	SELECT *, 
		ROW_NUMBER() OVER(PARTITION BY user_id ORDER BY login_date DESC) AS starting_as_latest
	FROM logins
	)
SELECT l1.user_id, l1.login_date AS first_login_date, l2.login_date AS latest_login_date
FROM login_date_first l1
JOIN login_date_latest l2
ON l1.user_id = l2.user_id
WHERE l1.starting_as_first = 1
AND 
l2.starting_as_latest = 1;

--üîπ LEVEL 4 ‚Äî Advanced Window Logic (Data Engineer Level)
-- Q10. From table: employees(emp_id, dept_id, salary)
-- Find the top 3 salaries per department, but return all employees tied at the 3rd position.
WITH TOP_3_SALARIES_PER_DEPT AS (
	SELECT *, DENSE_RANK() OVER(PARTITION BY dept_id ORDER BY salary DESC) AS d
	FROM employees
	) SELECT *
	FROM TOP_3_SALARIES_PER_DEPT
	WHERE d <= 3;

-- Q11. From table: transactions(user_id, txn_date, amount)
-- Assign a sequential transaction number per user ordered by transaction date.
SELECT *, ROW_NUMBER() OVER(PARTITION BY user_id ORDER BY txn_date ASC) AS transaction_number
FROM transactions;

-- Q12. üî• Very Common Interview Question
-- From table: employees(emp_id, dept_id, salary)
-- Find departments where at least 2 employees share the same salary.‚ùå
SELECT dept_id 
FROM employees e1
WHERE EXISTS (
	SELECT dept_id, DENSE_RANK() OVER(PARTITION BY dept_id ORDER BY salary) AS rank_for_dept_wise_salary
	FROM employees
	WHERE dept_id = e1.dept_id
	GROUP BY dept_id
	HAVING COUNT(rank_for_dept_wise_salary) >= 2
	);

--üîπ LEVEL 5 ‚Äî Window Functions (Tricky / Thinking Required)
-- Q13. From table: orders(order_id, customer_id, order_date)
-- Identify repeat customers:
-- First order ‚Üí label as New
-- Subsequent orders ‚Üí label as Repeat
WITH category AS (
	SELECT *, ROW_NUMBER() OVER(PARTITION BY customer_id ORDER BY order_date ASC) AS sequence_of_order
	FROM orders
	)
SELECT *, CASE
	WHEN sequence_of_order = 1 THEN 'New'
	ELSE 'Repeat'
	END AS category_of_customers
FROM category;

-- Q14. From table: employees(emp_id, dept_id, salary, salary_month)
-- Find employees whose salary rank improved compared to the previous month
-- (Table also has salary_month).
/*
emp_id| dept_id| salary| salary_month| sal_mon_r | sal_r
1	601		2500	JAN		3		2		
1	601		2565	FEB		2		1			
1	601		2565	MAR 	1		1			
---------------------------------------------------------------------
2	601		2300	NOV		2		1		
2	601		2300	DEC 	1		1		
---------------------------------------------------------------------
3	604		1900	APR		3		3		
3	604		1920	MAY		2		2		
3	604		1940	JUN		1  		1				

*/‚ùå
--You ranked by salary_month DESC (wrong)
--You compared two unrelated ranks
--You did not compare previous month rank
WITH rank_as_per_month AS (
	SELECT *, DENSE_RANK() OVER(PARTITION BY dept_id, emp_id ORDER BY salary_month DESC) AS salary_month_wise_rank,
	DENSE_RANK() OVER(PARTITION BY dept_id, emp_id ORDER BY salary DESC) AS salary_wise_rank
	FROM employees
	)
SELECT emp_id
FROM rank_as_per_month
WHERE salary_month_wise_rank = salary_wise_rank
GROUP BY emp_id
HAVING COUNT(*) > 1;

-- Q15. üíÄ Interview Killer
-- From table: scores(student_id, exam_date, marks)
-- Find students whose rank improved in consecutive exams.
/*
PARTITION BY student_id| exam_date ASC| marks | rank OVER(ORDER BY exam_date) | rank OVER(ORDER BY marks DESC)
1	01-01-2026	97	1	2
1	02-01-2026	96	2	3
1	03-01-2026	99	3	1
---------------------------------
2	01-01-2026	98	1	1
2 	02-01-2026	91	2	4
2	03-01-2026	94	3	3
2	04-01-2026	95	4	2
----------------------------------
3	01-01-2026	98	1	1
3 	02-01-2026	92	2	2
3	03-01-2026	92	3	2
3	04-01-2026	92	4	2

*/‚ùå
--Ranking by exam order ‚â† ranking improvement
--Must compare rank vs previous rank
--Needs LAG()
WITH rank_as_per_exam_date_marks AS (
	SELECT *, DENSE_RANK() OVER(PARTITION BY student_id ORDER BY exam_date ASC) AS rank_as_per_examdate,
	DENSE_RANK() OVER(PARTITION BY student_id ORDER BY marks DESC) AS rank_as_per_marks
	FROM scores
	)
SELECT student_id
FROM rank_as_per_exam_date_marks
WHERE rank_as_per_examdate = rank_as_per_marks
GROUP BY student_id
HAVING COUNT(*) >= 1;
