--ðŸ”¹ LEVEL 1 â€” Basic Date Difference
-- Q1. Table: orders(order_id, order_date, delivery_date) Find the number of days taken to deliver each order.
SELECT order_id, DATEDIFF(delivery_date, order_date) AS days_taken_to_deliver FROM orders;

-- Q2. Table: employees(emp_id, joining_date). Find employees who joined within the last 30 days.
SELECT * FROM employees WHERE DATEDIFF(CURRENT_DATE, joining_date) <= 30;

-- Q3. Table: subscriptions(user_id, start_date, end_date) Find subscription duration (in days) for each user.
SELECT user_id, DATEDIFF(end_date, start_date) AS subscription_duration(in_days) FROM subscriptions;

--ðŸ”¹ LEVEL 2 â€” Date Difference + Filtering
-- Q4. Table: logins(user_id, login_date) Find users who did not log in for more than 7 days.
SELECT user_id
FROM logins
GROUP BY user_id
HAVING DATEDIFF(CURRENT_DATE, MAX(login_date)) > 7;

-- Q5. Table: orders(order_id, order_date, payment_date) Find orders where payment was delayed by more than 3 days.
SELECT order_id FROM orders WHERE DATEDIFF(payment_date, order_date) > 3;

-- Q6. Table: employees(emp_id, joining_date, exit_date) Find employees whose tenure was more than 2 years.
SELECT emp_id FROM employees WHERE DATEDIFF(exit_date, joining_date) >= 730;

-- OR --
SELECT emp_id FROM employees WHERE exit_date >= joining_date + INTERVAL 2 YEAR;


--ðŸ”¹ LEVEL 3 â€” Date Difference + GROUP BY
-- Q7. Table: orders(order_id, customer_id, order_date) Find customers whose average gap between consecutive orders is more than 30 days.
WITH gap AS (
	SELECT customer_id, DATEDIFF(order_date, LAG(order_date) OVER(PARTITION BY customer_id ORDER BY order_date)) AS gap_in_days
	FROM orders 
	) SELECT customer_id
	FROM gap
	GROUP BY customer_id
	HAVING AVG(gap_in_days) >= 30;

-- Q8. Table: logins(user_id, login_date) Find users who logged in on at least 10 distinct days in the last 30 days.
SELECT user_id
FROM logins
WHERE login_date >= CURRENT_DATE - INTERVAL 30 DAY
GROUP BY user_id
HAVING COUNT(DISTINCT login_date) >= 10;

-- ðŸ”¹ LEVEL 4 â€” Date Difference + Window Functions (Interview Favorite)
-- Q9. Table: transactions(user_id, txn_date) Find the maximum gap (in days) between consecutive transactions for each user.
WITH g AS (
	SELECT user_id, txn_date, LAG(txn_date) OVER(PARTITION BY user_id ORDER BY txn_date ASC) AS lg, DATEDIFF(txn_date, lg) AS gap
	FROM transactions
	) SELECT user_id, MAX(gap) AS maximum_gap
	FROM g 
	GROUP BY user_id;

-- Q10. Table: logins(user_id, log_date) Find users who logged in for at least 5 consecutive days.\
WITH cte AS (
  SELECT user_id,
         log_date,
         DATE_SUB(log_date,
                  INTERVAL ROW_NUMBER() OVER(PARTITION BY user_id ORDER BY log_date) DAY) AS grp
  FROM logins
)
SELECT user_id
FROM cte
GROUP BY user_id, grp
HAVING COUNT(*) >= 5;


--ðŸ”¥ Very common interview question
--ðŸ”¹ LEVEL 5 â€” Advanced / Data Engineering Scenarios
-- Q11. Table: orders(order_id, order_date, ship_date, delivery_date) 
/*
Classify orders as:

'Fast' â†’ delivered within 3 days of shipping

'Normal' â†’ 4â€“7 days

'Delayed' â†’ more than 7 days
*/
WITH d AS (
	SELECT order_id, order_date, ship_date, delivery_date, DATEDIFF(delivery_date, ship_date) AS dd
	FROM orders
	)
SELECT order_id, CASE
	WHEN dd <= 3 THEN 'Fast'
	WHEN dd BETWEEN (4 AND 7) THEN 'Normal'
	ELSE 'Delayed'
	END AS delivery_category
FROM d;

-- Q12. Table: users(user_id, signup_date) Find users who never returned after signup (only one login within 30 days).
WITH t AS (
	SELECT user_id, signup_date, LAG(signup_date) OVER(PARTITION BY user_id ORDER BY signup_date) AS lg, DATEDIFF(signup_date, lg) AS dd
	FROM users 
	ORDER BY user_id, signup_date
	)
SELECT user_id
FROM t
WHERE delay_from_signup >= 30
GROUP BY user_id
HAVING COUNT(*) = 1;

-- Q13. Table: events(user_id, event_date) Detect inactive users: 
/*
Active â†’ logged in within last 7 days

Dormant â†’ last login between 8â€“30 days ago

Churned â†’ no login for 30+ days
*/
SELECT user_id,
	CASE
	  WHEN DATEDIFF(CURRENT_DATE, MAX(event_date)) <= 7 THEN 'Active'
	  WHEN DATEDIFF(CURRENT_DATE, MAX(event_date)) BETWEEN 8 AND 30 THEN 'Dormant'
	  ELSE 'Churned'
	END AS user_category
FROM events
GROUP BY user_id;


/*
ðŸ”¹ BONUS â€” SQL Dialect Awareness

Answer using your DB (MySQL / PostgreSQL / SQL Server):

Q14.

Difference between:

DATEDIFF()

AGE()

TIMESTAMPDIFF()

INTERVAL

When would you use each?
*/
DATEDIFF() 
	Returns the difference in days between two dates.
	MySQL / SQL Server
	DATEDIFF(end_date, start_date)
AGE()
	Returns an INTERVAL, not just a number.
   QUERY:
	AGE(end_date, start_date)
   OUTPUT:
	2 years 3 mons 10 days

TIMESTAMPDIFF() 
	Returns difference between two timestamps in a unit you choose
	TIMESTAMPDIFF(unit, start_ts, end_ts)
	TIMESTAMPDIFF(HOUR, login_time, logout_time)

INTERVAL 
	Used for date arithmetic, not comparison by itself.
	date + INTERVAL 10 DAY
	date - INTERVAL 1 MONTH
