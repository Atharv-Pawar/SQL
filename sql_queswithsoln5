-- ğŸ”¹ SET 1 â€” JOIN Fundamentals (Must-Know)
-- Q1. INNER vs LEFT JOIN (Classic)
-- Tables:
-- employees(emp_id, dept_id)
-- departments(dept_id, dept_name)
-- ğŸ‘‰ Return all employees along with department name
-- ğŸ‘‰ If department does not exist, show NULL

-- Q2. âš ï¸ Interview Trap â€” WHERE vs ON
-- Same tables as Q1.
-- Return only employees belonging to â€˜HRâ€™ department,
-- but do NOT lose employees with NULL dept_id.
-- ğŸ‘‰ Write the query correctly and explain why condition placement matters.

-- Q3. Self Join (Very Common)
-- Table:
-- employees(emp_id, emp_name, manager_id)
-- ğŸ‘‰ Return:
-- employee_name | manager_name

-- ğŸ”¹ SET 2 â€” JOIN + Aggregation (Real Business Logic)
-- Q4.
-- Tables:
-- orders(order_id, customer_id, amount)
-- customers(customer_id, city)
-- ğŸ‘‰ Return city-wise total order amount

-- Q5. âš ï¸ Interview Favorite
-- Same tables.
-- ğŸ‘‰ Return customers who never placed any order
-- âš ï¸ Use JOIN, not EXISTS.

-- Q6.
-- Tables:
-- employees(emp_id)
-- projects(project_id, emp_id)
-- ğŸ‘‰ Return employees working on more than one project
-- âš ï¸ JOIN + GROUP BY required.

-- ğŸ”¹ SET 3 â€” JOIN + WINDOW FUNCTIONS (High Yield)
-- Q7.
-- Table:
-- employees(emp_id, dept_id, salary)
-- ğŸ‘‰ Return:
-- emp_id | dept_id | salary | dept_avg_salary

-- Q8. âš ï¸ Very Common Interview Question
-- Same table.
-- ğŸ‘‰ Return employees whose salary is above department average
-- âš ï¸ Must use window function, no subquery filter.

-- Q9.
-- Table:
-- sales(order_id, sale_date, amount)
-- ğŸ‘‰ Return:
-- order_id | sale_date | amount | running_total
-- ğŸ‘‰ Running total ordered by sale_date

-- ğŸ”¹ SET 4 â€” Ranking & Comparison (Interview Gold)
-- Q10.
-- Table:
-- employees(emp_id, dept_id, salary)

-- ğŸ‘‰ Return top 2 highest paid employees per department
-- âš ï¸ Use window function
-- âš ï¸ Handle salary ties correctly

-- Q11.
-- Table:
-- scores(student_id, exam_date, marks)
-- ğŸ‘‰ Return:
-- student_id | exam_date | marks | previous_marks

-- Q12. âš ï¸ Logic Test
-- Same table.
-- ğŸ‘‰ Return students whose marks continuously increased in consecutive exams.

-- ğŸ”¹ SET 5 â€” JOIN + Date Logic (Interview Realism)
-- Q13.
-- Tables:
-- orders(order_id, order_date)
-- returns(order_id, return_date)

-- ğŸ‘‰ Return orders that were never returned
-- âš ï¸ Use JOIN, not NOT IN.

-- Q14.
-- Table:
-- logins(user_id, login_date)
-- ğŸ‘‰ Return users who logged in on consecutive days

-- ğŸ”¹ SET 6 â€” Debug & Fix (Interview Killer)
-- Q15. âŒ Whatâ€™s wrong?
-- SELECT e.emp_id, d.dept_name
-- FROM employees e
-- LEFT JOIN departments d
-- WHERE d.dept_name = 'IT';


-- ğŸ‘‰ Explain + fix.
-- Q16. âŒ Fix the logic
-- SELECT emp_id,
--        salary,
--        AVG(salary) OVER() AS avg_salary
-- FROM employees
-- WHERE salary > avg_salary;

-- ğŸ”¹ SET 7 â€” FINAL INTERVIEW QUESTION ğŸ’€
-- Q17.
-- Tables:
-- orders(order_id, customer_id, order_date, amount

-- ğŸ‘‰ For each customer, return:
-- customer_id
-- first_order_date
-- last_order_date
-- total_amount

-- âš ï¸ Constraints:
-- Single SELECT
-- Use window functions
-- No GROUP BY in outer query
